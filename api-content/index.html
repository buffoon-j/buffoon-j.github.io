{"posts":[{"title":"六个简单常见的基础题","content":"六个简单常见的基础题 斐波那契数列 描述 大家都知道斐波那契数列，现在要求输入一个正整数 n，请你输出斐波那契数列的第 n 项。 斐波那契数列具体为：1，1，2，3，5，8，13，... 即从第三项开始每一项为前两项的和。 输入描述： 一个正整数n 输出描述： 输出一个正整数。 import java.util.Scanner; public class Main { public static void main(String[] args) { int n, a, b, c; a = 1; b = 1; c = 2; Scanner scanner = new Scanner(System.in); n = scanner.nextInt(); for (int i = 0; i &lt; n - 1; i++) { if(n == 1 || n == 2) { break; } else { // 在这个循环开始之前，第i项为a，b为第i+1项，c为第i+2项 c = a + b; a = b; b = c; } } System.out.println(a); } } 求最大公约数和最小公倍数 描述： 输入两个正整数,求这两个数的最大公约数和最小公倍数。 输入描述： 两个正整数m，n 输出描述： m，n的最大公约数和最小公倍数 import java.util.Scanner; public class Main { public static void main(String[] args) { int m, n; Scanner scanner = new Scanner(System.in); m = scanner.nextInt(); n = scanner.nextInt(); // 最大公约数 for (int i = Math.min(m, n); i &gt; 0; i--) { if (m % i == 0 &amp;&amp; n % i == 0) { System.out.print(i + &quot; &quot;); break; } } // 最小公倍数 for (int i = 1; i &lt;= n; i++) { if ((m * i) % n == 0) { System.out.print(m * i); break; } } } } 数组排序 描述 输入一个正整数n,输入一个含n个元素数组，按对这个数进行从小到大的排序。数组长度为0-20。 输入描述： 数组元素个数n 和 数组元素 输出描述 排好序的若干整数 import java.util.Scanner; public class Main { public static void main(String[] args) { int n; int[] arr = new int[20]; Scanner scanner = new Scanner(System.in); n = scanner.nextInt(); for (int i = 0; i &lt; n; i++) { arr[i] = scanner.nextInt(); } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n - 1 - i; j++) { if (arr[j] &gt; arr[j+1]) { int exchange; exchange = arr[j]; arr[j] = arr[j+1]; arr[j+1] = exchange; } } } for (int i = 0; i &lt; n; i++) { System.out.printf(&quot;%d &quot;, arr[i]); } } } 两数之和 描述： 给定一个数组(1, 3, 5, 7, 9, 11)，用户输入目标值target，请在数组中找到,两个数之和为target的数，返回数组下标，没有则返回Not Found。 输入描述： 一个整数target 输出描述： 两个数组下标 Not Found import java.util.Scanner; public class Main { public static void main(String[] args) { int[] arr = {1, 3, 5, 7, 11}; int left, right, target; left = 0; right = 4; target = new Scanner(System.in).nextInt(); while (left &lt; right) { if(target == arr[left] + arr[right]) { break; }else if(target &lt; arr[left] + arr[right]) { right--; }else { left++; } } if (left &lt; right) { System.out.printf(&quot;%d %d&quot;, left, right); }else { System.out.println(&quot;Not Found&quot;); } } } 门类继承题 描述： 编写代码，实现如下功能： 定义一个门类Door， 包含3个属性：宽度width 和 高度height ，颜色color。 包含2个方法：开门和关门。 开门方法：输出“门已经打开，请进！”。 关门方法：输出“门已经关闭，禁止进入！”。 定义一个木头门WOOD，继承Door 重写父类开门方法：输出门的高度 宽度 颜色 +“门已经打开，请进！” 重写父类关门方法：输出门的高度 宽度 颜色 +“门已经关闭，禁止进入！” 定义一个测试类，测试类定义一个main方法。分别创建 门对象 和 木头门对象， 为创建的木头门对象属性赋值, 调用开门和关门两个方法。 // Door.java public class Door { private int width; private int height; private String color; public void openDoor() { System.out.println(&quot;门已经打开，请进！&quot;); } public void closeDoor() { System.out.println(&quot;门已经关闭，禁止进入！&quot;); } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } } // Wood.java public class Wood extends Door { @Override public void openDoor() { System.out.printf(&quot;高度为：%d，宽度为：%d，颜色为：%s，门已经打开，请进！\\n&quot;, getHeight(), getWidth(), getColor()); } @Override public void closeDoor() { System.out.printf(&quot;高度为：%d，宽度为：%d，颜色为：%s，门已经关闭，禁止进入！\\n&quot;, getHeight(), getWidth(), getColor()); } } // Main.java public class Main { public static void main(String[] args) { Door door = new Door(); door.openDoor(); door.closeDoor(); Wood wood = new Wood(); wood.setColor(&quot;橙色&quot;); wood.setHeight(5); wood.setWidth(2); wood.openDoor(); wood.closeDoor(); } } 抽象类：汽车的轮子 描述： 请创建一个抽象类 Vehicle ，添加 NoOfWheels 抽象方法，并在 Vehicle的子类 Car 和 Motorbike 中重写 NoOfWheels 方法，让其输出其有几个轮子。在测试类中分别创建两个子类的对象并调用重写的方法。 输入描述： 无输入 输出描述： This car has four wheels This Motorbike has two wheels // Vehicle.java public abstract class Vehicle { public void noOfWheels() { System.out.println(&quot;The Vehicle has wheels.&quot;); } } // Car.java public class Car extends Vehicle { @Override public void noOfWheels() { System.out.println(&quot;This car has four wheels.&quot;); } } // Motorbike.java public class Motorbike extends Vehicle { @Override public void noOfWheels() { System.out.println(&quot;This Motorbike has two wheels.&quot;); } } // Main.java public class Main { public static void main(String[] args) { Car car = new Car(); car.noOfWheels(); Motorbike motorbike = new Motorbike(); motorbike.noOfWheels(); } } ","link":"https://buffoon-j.github.io/post/liu-ge-jian-dan-chang-jian-de-ji-chu-ti/"},{"title":"1.基础语法","content":"基础语法 关于左大括号 { 的位置 第一种叫K&amp;R风格，第二种叫微软风格。 这是两种不同的风格，微软风格出现比较晚，个人比较喜欢第一种。 注释 Java的三种注释格式： 单行注释 多行注释 文档注释 注意：多行注释不能进行嵌套。 数据类型 数据类型分为两大类 基本类型 引用类型 基本类型(Primitive Type) 名称 解释说明 byte 8-bit的整数，取值范围是[-128,127] short 16-bit的整数，取值范围是[-32768,32767] int 32-bit的整数，取值范围是- 2 的31次方到 2 的31次方-1 long 64-bit的整数，取值范围是- 2 的63次方到 2 的63次方-1 float 单精度32-bit IEEE 754 浮点数，取值范围是[1.40E-45F,3.4028235E38F] double 双精度64-bit IEEE 754 浮点数，取值范围是[4.9E-324,1.7976961348623157E308] boolean 布尔类型，有true、false两个值 char 单个16-bit的Unicode字符 引用类型(Reference Type) 引用类型的值是对对象的引用。 字面量 整数 // 十进制 byte v1 = 123; // 二进制（或者0B11001） short v2 = 0b11001; // 十六进制（或者0XF78A、0Xf78a） int v3 = 0xF78A; // 以用L或者l结尾的表示long类型（或者199l） long v4 = 199L; 浮点数 // 以F或者f结尾表示float类型（或者123.4f） float v5 = 123.4F; // 以D或者d结尾表示double类型（或者123.4d） double v6 = 123.4D; // 默认就是double类型 double v7 = 123.4; // 可以用科学计数法（E或者e） float v8 = 1.234E2F; double v9 = 1.234e2; 字符和字符串 // 用单引号表示字符 char v10 = 'A'; // 用双引号表示字符串 String v11 = &quot;ABCD&quot;; 布尔 boolean v12 = true; boolean v13 = false; 空值 String string = null; String空字符串与空值的区别 首先需要注意的是String是引用类型。 String str1 = &quot;ABCD&quot;; String str2 = &quot;&quot;; // 空串 String str3 = null; 由图可知str1指向了一个字符串&quot;ABCD&quot;,str2指向了一个空字符串&quot;&quot;，str3没有任何指向是一个空值。 转义序列（转义字符） 在数字中使用下划线 从Java7开始， 可以给数字添加下划线增强可读性，下划线不会影响数字的值。 int v14 = 1_0000_0000; int v15 = 0xFF_EC_DE_5E; int v16 = 0b11010010_01101001_10010100_10010010; double v17 = 1.23_45_67; long v18 = 1___0000_0000; 需要有以下几点注意： 不能再浮点数的小数点前后使用下划线 不能再数字的开头和末尾使用下划线 不能再X、B、F、D、L、E等特殊字母前后使用下划线 变量的初始化 任何变量在使用之前必须要先初始化（赋值）。 局部变量需要程序员手动初始化 **非局部变量（实例变量、类变量）**编译器会自动给未初始化的变量设置一个初始值。 运算符 运算符及其优先级 运算符 优先级 后缀 expr++ expr-- 一元（单目） ++expr --expr +expr -expr ~ ! 乘除模 * / % 加减 + - 位移 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 关系 &lt; &gt; &lt;= &gt;= instanceof 等价 == != 按位与 &amp; 按位异或 ^ 按位或 | 逻辑与 &amp;&amp; 逻辑或 || 三元（三目） ? : 赋值 = += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= 注意： 多个优先级一样的运算符一起使用时，按照结合性运算： 赋值运算符结合性是从右往左 其他运算符结合性是从左往右 为了保证运算符按照预期执行，尽量多使用小括号 算数表达式的结果必须被使用 关于赋值运算符结合性演示示例： //此示例可验证赋值运算符的结合性是从右往左 public class Operator { public static void main(String[] args) { int b = 10; int age = b += 30; System.out.println(age); } } 运行结果： 字符串拼接 可以使用 + 进行字符串的拼接 int age = 18; String name = &quot;Jack&quot;; double height = 1.78; System.out.println( &quot;My name is &quot; + name + &quot;, age is &quot; + age + &quot;, height is &quot; + height); 位运算 &gt;&gt;与&gt;&gt;&gt; &gt;&gt;(有符号右移)：最左用符号位补齐 &gt;&gt;&gt;(无符号位移)：最左用0补齐 二进制最高位（最左端）为符号位：0代表正，1代表负 System.out.println(-128 &gt;&gt; 2); System.out.println(-128 &gt;&gt;&gt; 2); 注意：对正数来说 &gt;&gt; 和 &gt;&gt;&gt; 是一样的 &amp;、|、^ &amp; （与）从高位开始比较，两位都为1结果才为1 ^（异或）从高位开始比较，两位相同则为0，不同则为1 |（或）从高位开始比较，有一个为1则为1，否则为0 布尔类型也可以使用这三个运算符 &amp;、|、^演示： int age1 = 0b10011; int age2 = 0b10110; int age3 = age1 &amp; age2; int age4 = age1 | age2; int age5 = age1 ^ age2; System.out.println(Integer.toBinaryString(age1)); System.out.println(Integer.toBinaryString(age2)); System.out.println(&quot;---------------&quot;); System.out.println(Integer.toBinaryString(age3)); System.out.println(Integer.toBinaryString(age4)); System.out.println(Integer.toBinaryString(age5)); System.out.println(true &amp; false); System.out.println(true &amp; true); System.out.println(false &amp; false); System.out.println(&quot;---------------&quot;); System.out.println(true | false); System.out.println(true | true); System.out.println(false | false); System.out.println(&quot;---------------&quot;); System.out.println(true ^ false); System.out.println(true ^ true); System.out.println(false ^ false); 通过观察发现在进行布尔类型的运算时，&amp;、|似乎与&amp;&amp;、||的作用一样。 但其实对比&amp;&amp;、||，&amp;、|少了短路功能。 短路功能演示示例： public class Operator { public static boolean getBoolean() { System.out.println(&quot;getBoolean&quot;); return true; } public static void main(String[] args) { System.out.println(true &amp;&amp; getBoolean()); System.out.println(&quot;------------------&quot;); System.out.println(false &amp;&amp; getBoolean()); System.out.println(&quot;------------------&quot;); System.out.println(true &amp; getBoolean()); System.out.println(&quot;------------------&quot;); System.out.println(false &amp; getBoolean()); } } 可以看到当&amp;&amp;前面是false时后面就不会调用getBoolean()方法，而&amp;前面是false的时候则会继续调用。||和|则是前面是true时，||会短路，|不会短路。 数据类型转换 拓宽基本类型转换（隐式转换） 范围小的转换为数据范围大的，可以自动转换。 一元数字提升 简单来说就是将byte、short、char类型的数字进行一元某些一元运算时自动提升为int类型。 执行一元数字提升的情况： 数组的索引（数组索引必须用int） 一元运算符+、-（表示数字正负） 按位取反~ 位移（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;） 部分示例： char c1 = 'A'; System.out.println(c1); System.out.println(+c1); char c1 = 'A'; char c2 = +c1;//报错 char c3 = 65;//不会报错 第二行代码报错：Type mismatch：cannot convert from int to char. 二元数字提升 提升一个或两个数字：可以理解为当多个数据数据范围不同的变量进行运算的时候，会自动转换为数字范围大的那一个。但是如果是byte、short、char之间的运算会自动转为int。 执行二元数字提升情况： 加（+）、减（-）、乘（*）、除（/）、取余（%） 比较（&lt;、&lt;=、&gt;、&gt;=） 判等（==、!=） 位运算（&amp;、^、|） 三目（?:） 注意：复合赋值运算自带数据类型转换。示例如下： byte v1 = 1; v1 = v1 + 1; v1 += 1; 第二行代码会报错：Type mismatch: cannot convert from int to byte. 窄化基本类型转换（强制转换） 数据范围大的转为数据范围小的，可能会丢失精度和范围，需要强制转换。（不符合上面拓宽基本类型转换规则的图示） 强制转换示例： short s = 512; char c = (char) s; byte b = (byte) c; double d = 1.23; float f = (float) d; int i = (int) d; **注意：**布尔类型不能与上述提到的数据类型转换。 关键字和标识符 关键字 48个关键字：abstract、assert、boolean、break、byte、case、catch、char、class、continue、default、do、double、else、enum、extends、final、finally、float、for、if、implements、import、int、interface、instanceof、long、native、new、package、private、protected、public、return、short、static、strictfp、super、switch、synchronized、this、throw、throws、transient、try、void、volatile、while 2个保留字：goto、const（在java里面还没有被用到） 3个特殊直接量：true、false、null 标识符 标识符：变量名、方法名、类名等，命名规则如下： 不限长度的Java字母、java数字序列，但必须以Java字母开头（区分大小写） 不能使用关键字 不能使用字面量true、false、null Java字母：Character.isJavaIdentifierStart方法返回true的字符，包括ASCII中的AZ、az、美元符（$）、下划线（_），中文，韩文，日文等字符。 Java字母或者Java数字：Character.isJavaIdentifierStart方法返回true的字符，Java数字包括ASCII中的0~9。 命名建议 变量名、方法名：小驼峰，比如myNamaAndAge 类名：大驼峰，比如MyNameAndAge 常量：比如MY_NAME_AND_AGE 数组 数组的创建 // 推荐使用 char[] arr 格式定义数组 // 不推荐使用 char arr[] 格式定义数组 int[] arr1; int[] arr2 = {}; // 空数组 int arr3[] = {}; // 空数组 // 定义的时候指定数组元素 int[] arr4 = new int[] { 1, 2, 3, 4 }; int[] arr5 = { 1, 2, 3, 4 }; // 定义的时候指定数组长度 int[] arr6 = new int[4]; arr6[0] = 1; arr6[1] = 2; arr6[2] = 3; arr6[3] = 4; // 多维数组 int[][][] arr7; int[] arr8[][]; 注意：在Java中，字符数组 != 字符串 字符数组： char[] 字符串：String 数组的内存 现有下面一段代码： public static void main(String[] args) { int[] array = new int[] { 11, 22, 33 }; System.out.println(array); } 当main方法运行时，会分配一段栈帧给main方法，然后main方法在自己的栈帧里面存放array这个引用变量，array存放的是第一个元素的地址，指向堆空间里存array数组元素的位置。 注意： Java数组属于引用类型 数组元素存放在堆空间 Java的堆内存申请会自动进行初始化 数组的遍历 int[] arr = { 11, 22, 33, 44 }; for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); } for (int element : arr) { System.out.println(element); } **注意：**直接打印数组会得到数组的哈希值。 访问数组的原理：随机访问、速度非常快、O(1)。 示例：假设array的地址为0x1110,要访问array[2] array[2] -&gt; 0x1110 + 2 * 4 , 然后直接去 0x1118访问 方法 方法的书写格式 修饰符 返回值类型 方法名(参数列表) { 方法体 } 可变参数 注意： 可变参数必须是方法中的最后一个参数，实际上是以数组的形式传入的。 如果不传入可变参数，那么在调用方法时是空数组，而不是null 可变参数示例： public static void main(String[] args) { System.out.println(sum( 1, 2, 3, 4 )); } public static int sum(int... numbers) { int result = 0; for (int i : numbers) { result += i; } return result; } JDK自带的System.out.printf方法使用了可变参数，格式字符串参考API文档的java.util.Formatter类。 String name = &quot;Jack&quot;; int age = 20; System.out.printf(&quot;My name is %s, my age is %d.&quot;, name, age); 参数的传递 基本类型 基本类型作为参数是值传递 基本类型作为返回值，返回的是值 引用类型 引用类型作为参数是引用传递（地址传递） 引用类型作为返回值，返回的是引用（地址） 方法签名 方法签名由两部分组成：方法名、参数类型 示例： // 下面这个方法的方法签名是：sum(int, long, double) public static double sum(int i, long l, double d) { return i + l + d; } **注意：**在同一个类中，不能定义两个方法签名一样的方法。 方法的重载 Java的方法支持重载：方法名相同，方法签名不同（参数的个数不同、参数的类型不同）。 **注意：**重载与返回值类型、参数名称无关。 示例： public static int sum(int a, int b ) { return a + b; } public static double sum(double a, double b) { return a + b; } 栈帧 栈帧随着方法的调用而创建，随着方法的结束而销毁，存储了方法的局部变量信息。 示例： public static void main(String[] args) { test1(10); test2(20); } public static void test1(int v) {} public static void test2(int v) { test3(30); } public static void test3(int v) {} 上述代码栈帧创建与销毁过程如下图所示： 由图可知，调用方式时创建了栈帧，方法调用结束后销毁了栈帧。 递归调用 示例： public static void main(String[] args) { System.out.println(sum(4)); } public static int sum(int n) { if (n &lt;= 1) { return n; } return n + sum(n - 1); } 这段程序的栈帧： 注意：此图中的黑色字是不存在的。知识为了方便理解。 注意： 如果递归调用没有终止，将会一直消耗栈空间，最终导致内存溢出（Stack Overflow）。 所以必须要有一个明确的结束递归的条件，也叫边界条件、递归基。 ","link":"https://buffoon-j.github.io/post/1ji-chu-yu-fa/"},{"title":"求立方体类Box的表面积和体积","content":"求立方体类Box的表面积和体积 题目 此题作为重学JavaSE的第一道基础题。 设计一个立方体类Box，定义三个属性，分别是长，宽，高。定义二个方法，分别计算并输出立方体的体积和表面积。 代码 //Box.java public class Box { private int width; private int height; private int length; private int area; private int volume; public Box(int width, int height, int length) { this.width = width; this.height = height; this.length = length; } public Box() { } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public int getLength() { return length; } public void setLength(int length) { this.length = length; } public int getArea() { return area; } public void setArea(int area) { this.area = area; } public int getVolume() { return volume; } public void setVolume(int volume) { this.volume = volume; } } //Calculator.java public class Calculator { public static int area(int length, int width, int height) { int area = length * width + length * height + width * height; area *= 2; return area; } public static int volume(int length, int width, int height) { int volume = length * width * height; return volume; } } //Operator.java import java.util.Scanner; public class Operator { public void operate(Box box){ Scanner scanner = new Scanner(System.in); int length = scanner.nextInt(); int width = scanner.nextInt(); int height = scanner.nextInt(); box.setArea(Calculator.area(length, width, height)); box.setVolume(Calculator.volume(length, width, height)); scanner.close(); } } //Main.java public class Main { public static void main(String[] args) { Operator operator = new Operator(); Box box = new Box(); operator.operate(box); System.out.println(&quot;area: &quot; + box.getArea() + &quot;\\nvolume: &quot; + box.getVolume()); } } 分析 类 用途 Box 用来存储立方体Box的长宽高以及面积体积等属性 Calculator 用来计算Box的面积体积 Operator 用来应对用户的输入以及类之间数据的传输 Main 创建Box对象和Operator对象以及输出结果 运行结果 总结 对好多基础知识仍不熟悉，这源于在一开始学习Java时的不认真，重学Java的计划仍需不断推进。 ","link":"https://buffoon-j.github.io/post/qiu-li-fang-ti-lei-box-de-bian-mian-ji-he-ti-ji/"},{"title":"匿名代码块与static代码块","content":"匿名代码块与static代码块 补充static关键词中关于静态方法块的内容。[1] 首先看一下测试代码 public class Person { // 构造方法 Person(){ System.out.println(&quot;构造方法&quot;); } // 匿名方法块 { System.out.println(&quot;匿名方法块&quot;); } // static方法块 static { System.out.println(&quot;静态方法块&quot;); } } class Test { public static void main(String[] args) { Person person1 = new Person(); System.out.println(&quot;=======================&quot;); Person person2 = new Person(); } } 运行结果： 由运行结果可知： 在类初次被加载的时候，会最先加载静态方法块，然后加载匿名方法块，最后在加载构造方法。 但静态方法块只会加载一次，在第二次加载类时，只会加载先加载匿名方法块和构造方法。 所以也可以用匿名代码块来进行一些初始赋值，一些只进行一次的操作则放在静态代码块里。 参考 遇见狂神说. 面向对象14：static关键字详解 ","link":"https://buffoon-j.github.io/post/ni-ming-dai-ma-kuai-yu-static-dai-ma-kuai/"},{"title":"IDEA中Maven配置问题","content":"IDEA中Maven配置问题 问题 初学maven，在设置idea的maven配置时发现了一个问题。我每次创建maven项目时，无论是否修改maven配置，都会使用IDEA自带的maven。 解决这个问题，只需要先关闭项目。 在最开始的页面进入设置。 只需要在这里设置Maven的路径和其他设置，就不会有创建新项目时，Maven的配置全部恢复默认的情况。 个人理解：可以理解为打开项目时的设置为针对某一项目的设置，并不是全局设置。关闭所有项目在初始页进行设置为全局设置。 参考 Steve_hanhaiLong. IDEA中配置Maven常见问题每次都需要更改setting设置，否则使用默认Maven，完美解决Maven的配置问题！ ","link":"https://buffoon-j.github.io/post/idea-zhong-maven-pei-zhi-wen-ti/"}]}